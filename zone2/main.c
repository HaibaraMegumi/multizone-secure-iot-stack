/*
 * Copyright(C) 2018 Hex Five Security, Inc. - All rights reserved.
 */

#include <limits.h>

#include <platform.h>
#include <libhexfive.h>

#define RV32

#include <pico_stack.h>
#include <pico_ipv4.h>
#include <pico_icmp4.h>
#include <pico_socket.h>
#include <pico_dev_xemaclite.h>

#include <wolfssl/wolfcrypt/settings.h>
#include <wolfssl/wolfcrypt/error-crypt.h>
#include <wolfssl/ssl.h>
#include <wolfssl/wolfcrypt/logging.h>

#define NUM_PING 10

#define ACK         0
#define IND         1
#define CTL         2
#define DAT         3
#define CTL_ACK     (1 << 0)
#define CTL_DAT     (1 << 1)
#define CTL_RST     (1 << 2)
#define CTL_PSH     (1 << 3)

#define MAX_QUEUE_LEN 64

struct queue {
    uint8_t wp;
    uint8_t rp;
    uint8_t flush;
    char data[MAX_QUEUE_LEN];
};

void qinit(struct queue *q)
{
    q->rp = 0;
    q->wp = 0;
    q->flush = 0;
}

uint32_t qtaken(struct queue *q)
{
    if (q->wp < q->rp) {
        return q->wp + UCHAR_MAX + 1 - q->rp;
    } else {
        return q->wp - q->rp;
    }
}

uint32_t qfree(struct queue *q)
{
    return MAX_QUEUE_LEN - qtaken(q);
}

uint8_t qfull(struct queue *q)
{
    return qtaken(q) == MAX_QUEUE_LEN;
}

uint8_t qempty(struct queue *q)
{
    return qtaken(q) == 0;
}

void qinsert(struct queue *q, char e)
{
    q->data[q->wp % MAX_QUEUE_LEN] = e;
    q->wp++;
}

char *qfront(struct queue *q)
{
    return &q->data[q->rp % MAX_QUEUE_LEN];
}

uint32_t qcontlen(struct queue *q)
{
    uint32_t rdp = q->rp % MAX_QUEUE_LEN;
    uint32_t wdp = q->wp % MAX_QUEUE_LEN;

    if (wdp <= rdp && q->wp != q->rp) {
        return MAX_QUEUE_LEN - rdp;
    } else {
        return wdp - rdp;
    }
}

static int finished = 0;

void *pico_zalloc(size_t size)
{
    void *ptr = malloc(size);
    if(ptr)
        memset(ptr, 0u, size);

    return ptr;
}

void pico_free(void *ptr)
{
    free(ptr);
}

pico_time PICO_TIME_MS(void)
{
    return (pico_time)(ECALL_CSRR_MCYCLE() * 1000 / CPU_FREQ);
}

pico_time PICO_TIME(void)
{
    return (pico_time)(ECALL_CSRR_MCYCLE() / CPU_FREQ);
}

void PICO_IDLE(void)
{
    ECALL_YIELD();
}

/* gets called when the ping receives a reply, or encounters a problem */
void cb_ping(struct pico_icmp4_stats *s)
{
    char host[30];
    pico_ipv4_to_string(host, s->dst.addr);
    if (s->err == 0) {
        /* if all is well, print some pretty info */
        printf("%lu bytes from %s: icmp_req=%lu ttl=%lu time=%lu ms\n", s->size,
                host, s->seq, s->ttl, (long unsigned int)s->time);
    } else {
        /* if something went wrong, print it and signal we want to stop */
        printf("PING %lu to %s: Error %d\n", s->seq, host, s->err);
    }
}

#define IAC "\xff"

#define WILL "\xfb"
#define DONT "\xfe"

#define ECHO "\x01"
#define SUPRESS_GO_AHEAD "\x03"
#define LINEMODE "\x22"

struct pico_socket *sock_client = NULL;
WOLFSSL_CTX *ctx = NULL;
WOLFSSL *ssl = NULL;

void cb_telnet(uint16_t ev, struct pico_socket *s)
{
    if (ev & PICO_SOCK_EV_CONN) {
        struct pico_ip4 ipaddr;
        uint16_t port;
        uint32_t yes = 1;
        const char mode[] = IAC DONT LINEMODE
                            IAC WILL SUPRESS_GO_AHEAD
                            IAC WILL ECHO;

        sock_client = pico_socket_accept(s, &ipaddr.addr, &port);
        pico_socket_setoption(sock_client, PICO_TCP_NODELAY, &yes);
        pico_socket_write(sock_client, mode, sizeof(mode));
    }

    if (ev & PICO_SOCK_EV_CLOSE) {
        sock_client = NULL;

        if (ev & PICO_SOCK_EV_RD) {
            pico_socket_shutdown(s, PICO_SHUT_WR);
        }
    }
}

void mzmsg_proc(struct queue *txq, struct queue *rxq)
{
    static int ack_pending = 0;
    static int ack_index = 0;
    static int flush = 0;
    static int resend = 0;
    static int msg[4] = {0,0,0,0};
    static int msg_out[4] = {-1,0,0,0};
    int tmp_msg[4] = {0,0,0,0};

    ECALL_RECV(1, (void*)tmp_msg);

    if (!(tmp_msg[0] == 0 && tmp_msg[1] == 0 && tmp_msg[2] == 0 && tmp_msg[3] == 0)) {
        memcpy(msg, tmp_msg, 4*sizeof(int));
    }

    if ((msg[CTL] & CTL_RST) != 0) {
        ack_pending = 0;
        ack_index = 0;
        memcpy(msg_out, (int[]){-1,0,0,0}, 4*sizeof(int));
        ECALL_SEND(1, (int[]){0,0,CTL_RST,0});
    }

    if ((msg[CTL] & CTL_DAT) != 0) {
        if (msg[IND] == (msg_out[ACK] + 1)) {
            if (qfree(txq) >= MZMSG_CHARS) {
                int ack = 0;
                char *data = (char*)&msg[DAT];

                while (*data != 0 && ack < MZMSG_CHARS) {
                    qinsert(txq, *data);
                    ack++;
                    data++;
                }

                msg_out[CTL] |= CTL_ACK;
                msg_out[ACK] = msg[IND];
                flush = 1;

                if ((msg[CTL] & CTL_PSH) != 0) {
                    txq->flush = 1;
                }
            }
        }
    }

    if (!ack_pending && rxq->flush) {
        msg_out[CTL] |= CTL_DAT;
        msg_out[IND] = ack_index;
        memcpy(&msg_out[DAT], qfront(rxq), 1);
        rxq->rp += 1;
        if (qempty(rxq))
            rxq->flush = 0;
        flush = 1;
        ack_pending = 1;
    }

    if (((msg[CTL] & CTL_ACK) != 0) & ack_pending) {
        if (msg[ACK] >= ack_index) {
            ack_index = msg[ACK] + 1;
            ack_pending = 0;
        }
    }

    if (flush != 0) {
        flush = 0;
        ECALL_SEND(1, (void*)msg_out);
    }
}

void telnet_client(struct pico_socket *client, struct queue *txq, struct queue *rxq)
{
    char buf[32];
    int bytes = 0;

    if (qfree(rxq) < MZMSG_CHARS || rxq->flush) {
        bytes = pico_socket_write(sock_client, qfront(rxq), qcontlen(rxq));
        rxq->rp += bytes;
        if (qcontlen(rxq) > 0) {
            bytes = pico_socket_write(sock_client, qfront(rxq), qcontlen(rxq));
            rxq->rp += bytes;
        }
        if (qempty(rxq))
            rxq->flush = 0;
    }

    if (qfree(txq) > 0) {
        bytes = pico_socket_read(sock_client, buf, 1);
        if (bytes > 0) {
            if (buf[0] == '\xff') { // swallow IAC sequences
                pico_socket_read(sock_client, buf, sizeof(buf));
            } else if (buf[0] != 0) {
                qinsert(txq, buf[0]);
                txq->flush = 1;
            }
        }
    }
}

#define PHY_ADDRESS 0x01
#define BMSR_REG 0x01
#define BMSR_LINK_STATUS 0x4

#define DO_QUOTE(X)  #X
#define QUOTE(X)     DO_QUOTE(X)

static const char cert_der[] = {
  0x30, 0x82, 0x02, 0xe4, 0x30, 0x82, 0x02, 0x4d, 0xa0, 0x03, 0x02, 0x01,
  0x02, 0x02, 0x14, 0x5a, 0x08, 0x03, 0x06, 0xbc, 0x81, 0x3b, 0x6a, 0xba,
  0x64, 0x50, 0x04, 0x29, 0x87, 0xe3, 0x1a, 0x65, 0x80, 0x9c, 0x98, 0x30,
  0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b,
  0x05, 0x00, 0x30, 0x81, 0x83, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,
  0x04, 0x06, 0x13, 0x02, 0x55, 0x4b, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03,
  0x55, 0x04, 0x08, 0x0c, 0x06, 0x4c, 0x6f, 0x6e, 0x64, 0x6f, 0x6e, 0x31,
  0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x06, 0x4c, 0x6f,
  0x6e, 0x64, 0x6f, 0x6e, 0x31, 0x1a, 0x30, 0x18, 0x06, 0x03, 0x55, 0x04,
  0x0a, 0x0c, 0x11, 0x77, 0x61, 0x72, 0x70, 0x42, 0x79, 0x74, 0x65, 0x73,
  0x20, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64, 0x31, 0x12, 0x30, 0x10,
  0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x09, 0x77, 0x61, 0x72, 0x70, 0x42,
  0x79, 0x74, 0x65, 0x73, 0x31, 0x22, 0x30, 0x20, 0x06, 0x09, 0x2a, 0x86,
  0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x01, 0x16, 0x13, 0x62, 0x6f, 0x72,
  0x61, 0x6e, 0x40, 0x77, 0x61, 0x72, 0x70, 0x62, 0x79, 0x74, 0x65, 0x73,
  0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x39, 0x30, 0x32,
  0x31, 0x35, 0x31, 0x33, 0x32, 0x39, 0x31, 0x31, 0x5a, 0x17, 0x0d, 0x32,
  0x30, 0x30, 0x32, 0x31, 0x35, 0x31, 0x33, 0x32, 0x39, 0x31, 0x31, 0x5a,
  0x30, 0x81, 0x83, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,
  0x13, 0x02, 0x55, 0x4b, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04,
  0x08, 0x0c, 0x06, 0x4c, 0x6f, 0x6e, 0x64, 0x6f, 0x6e, 0x31, 0x0f, 0x30,
  0x0d, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x06, 0x4c, 0x6f, 0x6e, 0x64,
  0x6f, 0x6e, 0x31, 0x1a, 0x30, 0x18, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c,
  0x11, 0x77, 0x61, 0x72, 0x70, 0x42, 0x79, 0x74, 0x65, 0x73, 0x20, 0x4c,
  0x69, 0x6d, 0x69, 0x74, 0x65, 0x64, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03,
  0x55, 0x04, 0x03, 0x0c, 0x09, 0x77, 0x61, 0x72, 0x70, 0x42, 0x79, 0x74,
  0x65, 0x73, 0x31, 0x22, 0x30, 0x20, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
  0xf7, 0x0d, 0x01, 0x09, 0x01, 0x16, 0x13, 0x62, 0x6f, 0x72, 0x61, 0x6e,
  0x40, 0x77, 0x61, 0x72, 0x70, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2e, 0x63,
  0x6f, 0x6d, 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
  0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00,
  0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xe9, 0xfa, 0xe8, 0x10, 0x18,
  0x54, 0x7b, 0x1c, 0x0c, 0xd6, 0x3b, 0xc2, 0x2d, 0xd6, 0xc6, 0x16, 0xe9,
  0x5a, 0x43, 0xb6, 0x8f, 0xd6, 0xcc, 0x0f, 0x99, 0x7d, 0x24, 0xc1, 0x52,
  0xb6, 0xb6, 0x07, 0x1f, 0xdb, 0xfb, 0x30, 0x27, 0xa4, 0x72, 0xe5, 0x4e,
  0xae, 0x33, 0xaa, 0x64, 0xf4, 0x07, 0xc4, 0x7a, 0xd2, 0x17, 0x81, 0x61,
  0xe6, 0xde, 0x7b, 0x88, 0xcd, 0x7e, 0x58, 0x92, 0xfd, 0xe1, 0x26, 0x4f,
  0x6b, 0xcc, 0x01, 0x3d, 0x63, 0xdc, 0x1e, 0xc6, 0xf2, 0xc4, 0x0d, 0x83,
  0x27, 0x22, 0xce, 0xff, 0x69, 0xd9, 0x8b, 0x1a, 0xc4, 0x3f, 0xd1, 0x80,
  0xd8, 0x34, 0x5f, 0xb2, 0x1a, 0x58, 0xdc, 0x63, 0x8d, 0x78, 0x88, 0x41,
  0xba, 0x08, 0x85, 0xdb, 0x48, 0xf8, 0x9f, 0xdb, 0x1d, 0xcc, 0x15, 0x60,
  0x93, 0xa3, 0x45, 0x06, 0xff, 0xee, 0xfb, 0xed, 0x56, 0x14, 0x1e, 0x19,
  0xae, 0x12, 0xfd, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x53, 0x30, 0x51,
  0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xeb,
  0x66, 0x21, 0xe9, 0xac, 0x17, 0xba, 0x16, 0xcd, 0x66, 0x11, 0x50, 0xf7,
  0x8b, 0x6c, 0x46, 0xc9, 0xdc, 0x9f, 0x40, 0x30, 0x1f, 0x06, 0x03, 0x55,
  0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xeb, 0x66, 0x21, 0xe9,
  0xac, 0x17, 0xba, 0x16, 0xcd, 0x66, 0x11, 0x50, 0xf7, 0x8b, 0x6c, 0x46,
  0xc9, 0xdc, 0x9f, 0x40, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01,
  0x01, 0xff, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06,
  0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00,
  0x03, 0x81, 0x81, 0x00, 0x38, 0xe6, 0xe1, 0x89, 0x08, 0xd7, 0xfd, 0x77,
  0x3a, 0x3f, 0xe5, 0x5e, 0x43, 0x9c, 0x49, 0x08, 0x5f, 0x1c, 0xe6, 0x1d,
  0x74, 0xe0, 0x9f, 0xad, 0x18, 0x80, 0xb9, 0xca, 0xd6, 0xfd, 0x8e, 0x96,
  0xfd, 0x48, 0xd8, 0xf0, 0x50, 0xf7, 0x43, 0x9a, 0xf3, 0x6b, 0xd0, 0xa3,
  0xd5, 0x32, 0x51, 0xb6, 0xb5, 0x2b, 0x06, 0x21, 0xb0, 0x07, 0x06, 0x79,
  0xd9, 0x70, 0xd0, 0x13, 0xf7, 0x2c, 0xa6, 0xf9, 0xdc, 0x8b, 0x22, 0x84,
  0xd1, 0x87, 0x66, 0xa3, 0x0b, 0xa5, 0xbd, 0x67, 0x51, 0xca, 0xbf, 0xca,
  0x03, 0x69, 0x96, 0x12, 0x1f, 0x44, 0xa1, 0x38, 0xbd, 0xa3, 0x56, 0x5e,
  0xbe, 0xd4, 0x9b, 0x57, 0xc0, 0xda, 0xcd, 0x49, 0xaf, 0xeb, 0x14, 0x77,
  0x27, 0x9c, 0x8e, 0xde, 0x2b, 0x02, 0x33, 0x4c, 0x97, 0x7f, 0xef, 0xd7,
  0x69, 0x4f, 0xa0, 0x83, 0xf5, 0x57, 0xb6, 0x68, 0x16, 0x20, 0x8b, 0xd2
};

static const char key_der[] = {
  0x30, 0x82, 0x02, 0x5d, 0x02, 0x01, 0x00, 0x02, 0x81, 0x81, 0x00, 0xe9,
  0xfa, 0xe8, 0x10, 0x18, 0x54, 0x7b, 0x1c, 0x0c, 0xd6, 0x3b, 0xc2, 0x2d,
  0xd6, 0xc6, 0x16, 0xe9, 0x5a, 0x43, 0xb6, 0x8f, 0xd6, 0xcc, 0x0f, 0x99,
  0x7d, 0x24, 0xc1, 0x52, 0xb6, 0xb6, 0x07, 0x1f, 0xdb, 0xfb, 0x30, 0x27,
  0xa4, 0x72, 0xe5, 0x4e, 0xae, 0x33, 0xaa, 0x64, 0xf4, 0x07, 0xc4, 0x7a,
  0xd2, 0x17, 0x81, 0x61, 0xe6, 0xde, 0x7b, 0x88, 0xcd, 0x7e, 0x58, 0x92,
  0xfd, 0xe1, 0x26, 0x4f, 0x6b, 0xcc, 0x01, 0x3d, 0x63, 0xdc, 0x1e, 0xc6,
  0xf2, 0xc4, 0x0d, 0x83, 0x27, 0x22, 0xce, 0xff, 0x69, 0xd9, 0x8b, 0x1a,
  0xc4, 0x3f, 0xd1, 0x80, 0xd8, 0x34, 0x5f, 0xb2, 0x1a, 0x58, 0xdc, 0x63,
  0x8d, 0x78, 0x88, 0x41, 0xba, 0x08, 0x85, 0xdb, 0x48, 0xf8, 0x9f, 0xdb,
  0x1d, 0xcc, 0x15, 0x60, 0x93, 0xa3, 0x45, 0x06, 0xff, 0xee, 0xfb, 0xed,
  0x56, 0x14, 0x1e, 0x19, 0xae, 0x12, 0xfd, 0x02, 0x03, 0x01, 0x00, 0x01,
  0x02, 0x81, 0x80, 0x52, 0xea, 0x0f, 0x02, 0x65, 0x1c, 0xca, 0xe3, 0x8d,
  0xc8, 0xfd, 0x34, 0x3a, 0x7a, 0x39, 0x88, 0x34, 0xf9, 0x3f, 0xb5, 0x9a,
  0x13, 0x4c, 0x0c, 0xdb, 0x1f, 0x75, 0xbe, 0xec, 0x48, 0xc3, 0x08, 0x93,
  0x49, 0xa9, 0x21, 0xcf, 0x6a, 0x7f, 0x2c, 0xb3, 0x4d, 0x18, 0x11, 0xf1,
  0xe4, 0x68, 0x3c, 0x40, 0x29, 0xe3, 0x1a, 0x7e, 0x4f, 0x09, 0xd8, 0x4d,
  0x0a, 0x45, 0x13, 0xae, 0x43, 0x39, 0x5d, 0x64, 0x7b, 0x8f, 0xae, 0xad,
  0x16, 0x8a, 0x9e, 0xd9, 0x87, 0xa8, 0xcd, 0x14, 0xe9, 0x13, 0xba, 0xee,
  0x55, 0x73, 0x4a, 0x3e, 0x5f, 0x12, 0x3a, 0xca, 0xf1, 0x55, 0x3e, 0x55,
  0x48, 0xfc, 0xc3, 0x59, 0xae, 0x69, 0x2a, 0xaa, 0x4c, 0xa9, 0x89, 0x22,
  0x79, 0x65, 0x56, 0x09, 0x60, 0x26, 0xdd, 0x73, 0x3d, 0xc1, 0xa3, 0x7c,
  0x4a, 0x9e, 0x24, 0x2a, 0xda, 0x14, 0xcb, 0x37, 0x91, 0xbf, 0x21, 0x02,
  0x41, 0x00, 0xff, 0x27, 0xea, 0x00, 0x20, 0xc5, 0x65, 0x9e, 0xaa, 0xa3,
  0x24, 0x0f, 0xa6, 0x03, 0xde, 0x70, 0x1e, 0xd7, 0x69, 0x3f, 0xba, 0xf6,
  0x85, 0xfd, 0xd6, 0xb6, 0x14, 0xca, 0x5e, 0x15, 0x89, 0x4f, 0x75, 0x08,
  0x54, 0xc4, 0x30, 0xb1, 0x94, 0xb4, 0xd1, 0xa9, 0xc8, 0x5f, 0x3f, 0x38,
  0xc9, 0x3e, 0x3c, 0x5f, 0xca, 0x8e, 0xcb, 0xdf, 0x22, 0x74, 0x40, 0x01,
  0x85, 0xf5, 0x92, 0x70, 0x48, 0xb3, 0x02, 0x41, 0x00, 0xea, 0xc1, 0x0f,
  0x21, 0x55, 0xb4, 0x83, 0x23, 0xbc, 0x4b, 0x5d, 0xcd, 0x08, 0xe5, 0xcb,
  0x9a, 0x06, 0xc0, 0x74, 0x00, 0x66, 0x23, 0x6f, 0x4a, 0x4d, 0xd8, 0xc0,
  0x6f, 0x8e, 0xab, 0x47, 0xdf, 0xee, 0x3c, 0x71, 0xb5, 0x90, 0xe8, 0x7c,
  0xbf, 0x5b, 0x40, 0xbe, 0xad, 0x44, 0x42, 0x4e, 0xcb, 0x36, 0x99, 0x07,
  0x59, 0x0a, 0xe9, 0x7a, 0xf8, 0xfb, 0xbe, 0xe8, 0xee, 0x1a, 0x1a, 0x2d,
  0x8f, 0x02, 0x40, 0x0d, 0x06, 0xea, 0xa9, 0x8b, 0x02, 0xc9, 0x07, 0x6a,
  0xca, 0xdd, 0x82, 0x77, 0x05, 0x67, 0x8b, 0xed, 0xe7, 0x2d, 0x96, 0x75,
  0x63, 0x34, 0xc0, 0x1b, 0x00, 0x3c, 0xdb, 0x80, 0x26, 0x35, 0x56, 0x7b,
  0x31, 0x2b, 0xb2, 0xc0, 0x91, 0xb0, 0x77, 0xf2, 0xe4, 0x6a, 0x38, 0x82,
  0xaf, 0xd1, 0x86, 0x7d, 0xea, 0x9e, 0x1a, 0xe0, 0x49, 0xca, 0x26, 0x89,
  0x46, 0x0a, 0xa2, 0xd9, 0x11, 0x26, 0x85, 0x02, 0x41, 0x00, 0x83, 0xe0,
  0x10, 0x6f, 0xd9, 0x85, 0x9e, 0x65, 0xe4, 0xd1, 0x31, 0xd0, 0x8c, 0xbf,
  0x0a, 0xb1, 0x6c, 0x39, 0x90, 0xf0, 0xe8, 0x6f, 0xdf, 0x85, 0x0e, 0x56,
  0x45, 0x44, 0x66, 0x11, 0x32, 0x3f, 0x49, 0xc6, 0x0a, 0xda, 0xc4, 0x9c,
  0xd5, 0xf7, 0x69, 0x7b, 0xe5, 0xa1, 0xd0, 0x46, 0xaf, 0x9c, 0xd8, 0xfe,
  0xfe, 0x71, 0xb6, 0xff, 0x92, 0x65, 0x6c, 0x86, 0xc2, 0xb3, 0x7f, 0x56,
  0x55, 0x61, 0x02, 0x41, 0x00, 0xd8, 0x70, 0xee, 0x44, 0x99, 0x2e, 0xe3,
  0x17, 0x5d, 0x14, 0x5c, 0x86, 0x6d, 0xaa, 0xf2, 0x48, 0x91, 0x79, 0x4e,
  0x13, 0x4e, 0x24, 0xc4, 0x7c, 0xae, 0x3b, 0x62, 0x85, 0xd5, 0x68, 0xc9,
  0x06, 0xf4, 0xe1, 0x0f, 0x64, 0xfa, 0x08, 0x21, 0xbf, 0xf3, 0xad, 0xed,
  0x36, 0x20, 0xc7, 0x61, 0xdc, 0xf5, 0x02, 0x94, 0xe6, 0xbc, 0xe7, 0x00,
  0x60, 0xf4, 0xa9, 0x36, 0x8b, 0x00, 0xd4, 0xb6, 0x14
};

void cb_tls(uint16_t ev, struct pico_socket *s)
{
    struct pico_socket *sock_tls;

    if (ev & PICO_SOCK_EV_CONN) {
        struct pico_ip4 ipaddr;
        uint16_t port;

        sock_tls = pico_socket_accept(s, &ipaddr.addr, &port);
        ssl = wolfSSL_new(ctx);
        wolfSSL_SetIOReadCtx(ssl, sock_tls);
        wolfSSL_SetIOWriteCtx(ssl, sock_tls);
    }

    if (ev & PICO_SOCK_EV_CLOSE) {
        wolfSSL_free(ssl);
        ssl = NULL;

        if (ev & PICO_SOCK_EV_RD) {
            pico_socket_shutdown(s, PICO_SHUT_WR);
        }
    }
}

void tls_client(WOLFSSL *ssl, struct queue *txq, struct queue *rxq)
{
    int ret, error;
    char buf[32];
    int bytes;

    ret = wolfSSL_accept(ssl);
    error = wolfSSL_get_error(ssl, 0);

    if (ret != WOLFSSL_SUCCESS) {
        ret = wolfSSL_accept(ssl);
    } else {
        if (qfree(rxq) < MZMSG_CHARS || rxq->flush) {
            bytes = wolfSSL_write(ssl, qfront(rxq), qcontlen(rxq));
            rxq->rp += bytes;
            if (qcontlen(rxq) > 0) {
                bytes = wolfSSL_write(ssl, qfront(rxq), qcontlen(rxq));
                rxq->rp += bytes;
            }
            if (qempty(rxq))
                rxq->flush = 0;
        }

        if (qfree(txq) > 0) {
            bytes = wolfSSL_read(ssl, buf, 1);
            if (bytes > 0) {
                if (buf[0] == '\xff') { // swallow IAC sequences
                    wolfSSL_read(ssl, buf, sizeof(buf));
                } else if (buf[0] != 0) {
                    qinsert(txq, buf[0]);
                    txq->flush = 1;
                }
            }
        }
    }
}

static int wolfRecv(WOLFSSL *ssl, char *buf, int sz, void *ctx)
{
    int ret;
    struct pico_socket *sock_tls = (struct pico_socket*)ctx;

    ret = pico_socket_read(sock_tls, buf, sz);

    if (ret == 0) {
        return WOLFSSL_CBIO_ERR_WANT_READ;
    } else {
        return ret;
    }
}

static int wolfSend(WOLFSSL *ssl, char *buf, int sz, void *ctx)
{
    int ret;
    struct pico_socket *sock_tls = (struct pico_socket*)ctx;

    ret = pico_socket_write(sock_tls, buf, sz);

    if (ret == 0) {
        return WOLFSSL_CBIO_ERR_WANT_WRITE;
    } else {
        return ret;
    }
}

int main(int argc, char *argv[]){
    int id;
    uint16_t telnet_port = short_be(23);
    uint16_t tls_port = short_be(443);
    uint32_t yes = 1;
    struct pico_ip4 ipaddr, netmask;
    struct pico_socket* socket;
    struct pico_device* dev;
    struct queue mzmsg_to1, mzmsg_from1;
    uint16_t bmsr;
    int ret;

    do {
        ECALL_YIELD();
        bmsr = pico_xemaclite_mdio_read(PHY_ADDRESS, BMSR_REG);
    } while ((bmsr & BMSR_LINK_STATUS) == 0);

    qinit(&mzmsg_to1);
    qinit(&mzmsg_from1);

    /* initialise the stack. Super important if you don't want ugly stuff like
     * segfaults and such! */
    pico_stack_init();
    wolfSSL_Init();

    printf("pico stack initialized\n");

    dev = pico_xemaclite_create();
    if (!dev) {
        printf("Could not initialize device\n");
        return -1;
    }

    /* assign the IP address to the tap interface */
    #ifndef IPADDR
        #error "IPADDR not defined! Please provide it via `make IPADDR=....`"
    #endif
    pico_string_to_ipv4(QUOTE(IPADDR), &ipaddr.addr);
    #ifndef NETMASK
        #warning "NETMASK not defined, assuming 255.255.255.0. You can provide one via `make NETMASK=...`"
        #define NETMASK "255.255.255.0"
    #endif
    pico_string_to_ipv4(QUOTE(NETMASK), &netmask.addr);
    pico_ipv4_link_add(dev, ipaddr, netmask);

    printf("Listening on port %d\n", short_be(telnet_port));
    socket = pico_socket_open(PICO_PROTO_IPV4, PICO_PROTO_TCP, cb_telnet);
    if (!socket) {
        printf("Could not open socket!\n");
        return -1;
    }

    pico_socket_setoption(socket, PICO_TCP_NODELAY, &yes);

    if (pico_socket_bind(socket, &ipaddr, &telnet_port) != 0) {
        printf("Could not bind!\n");
        return -1;
    }

    if (pico_socket_listen(socket, 1) != 0) {
        printf("Could not start listening!\n");
        return -1;
    }

    ctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method());
    if (!ctx) {
        printf("Could not initialize wolfSSL context!\n");
        return -1;
    }
    wolfSSL_CTX_SetIORecv(ctx, wolfRecv);
    wolfSSL_CTX_SetIOSend(ctx, wolfSend);

    ret = wolfSSL_CTX_use_certificate_buffer(ctx, cert_der, sizeof(cert_der), SSL_FILETYPE_ASN1);
    if (ret != SSL_SUCCESS) {
        printf("Could not load certificate!\n");
        return -1;
    }

    ret = wolfSSL_CTX_use_PrivateKey_buffer(ctx, key_der, sizeof(key_der), SSL_FILETYPE_ASN1);
    if (ret != SSL_SUCCESS) {
        printf("Could not load private key!\n");
        return -1;
    }

    socket = pico_socket_open(PICO_PROTO_IPV4, PICO_PROTO_TCP, cb_tls);
    if (!socket) {
        printf("Could not open socket!\n");
        return -1;
    }

    if (pico_socket_bind(socket, &ipaddr, &tls_port) != 0) {
        printf("Could not bind!\n");
        return -1;
    }

    if (pico_socket_listen(socket, 1) != 0) {
        printf("Could not start listening!\n");
        return -1;
    }

    /* keep running stack ticks to have picoTCP do its network magic. Note that
     * you can do other stuff here as well, or sleep a little. This will impact
     * your network performance, but everything should keep working (provided
     * you don't go overboard with the delays). */
    while (finished != 1)
    {
        int msg[4] = {0,0,0,0};

        mzmsg_proc(&mzmsg_from1, &mzmsg_to1);

        if (sock_client) {
            telnet_client(sock_client, &mzmsg_to1, &mzmsg_from1);
        }

        if (ssl) {
            tls_client(ssl, &mzmsg_to1, &mzmsg_from1);
        }

        pico_stack_tick();

        ECALL_RECV(4, msg);
        if (msg[0]) ECALL_SEND(4, msg);
        ECALL_YIELD();
    }

    printf("finished !\n");
    return 0;
}
